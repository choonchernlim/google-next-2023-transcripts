{
    "title": "Secure your software supply chain with Go",
    "presentation_type": "Breakout",
    "categories": [
        "Application Developers",
        "DEV206"
    ],
    "video_id": "mierbketwXU",
    "time": "Aug 30 05:30 PM - 06:15 PM CDT",
    "transcript": "[Music]all right hello everyone uh thank youfor making it out and I hope you've hada great Google Cloud next so far umbefore we get started I just want youall to know this presentation will beabout 30 minutes and then afterward youall can uh queue up and ask questions atthe microphone over there um I'm Cameronand I am the product lead for the goprogramming language at Google uh todaywe're going to discuss software supplychain security what it is why it mattersand how the tools we ship with the goprogramming language can help you secureyour software supply chain at everystage of the software development lifecycle before we get started a secondabout me uh as I said I'm the PM leadfor go I've been on the go team for alittle over three years before go I wason the Google Cloud SDK uh I led uhlanguages and Frameworks Integrationsand the SDK in general uh and beforeGoogle I was a software developer at uhprop trading firm um I worked on highfrequency low latency trading strategiesand C++ and a little bit of java and nowI'm a go convert um the securityfeatures that I'll dig into during thispresentation are just a small part ofwhy I like go a whole lot more than theother stuff I've workedin now I'm sure most of you know what gois but it's helpful to start thispresentation by telling you why gostarted at Google in the first place andthe first and probably most importantpoint that I want to make about it isthat go is not just a programminglanguage it is a complete endtoendplatform for building production systemsthat was true in the beginning and it'sstill true today so we'll begin with thebeginning now I wasn't therebut the legend is that during a45-minute C++ build sometime in 2007 RobPike and Robert Greer scribble togethera vision of what would ultimately becomego if you've never heard of Robert orRob Robert was previously known for hiswork as the principal architect of theJava hotspot virtual machine and also onthe V8 JavaScript uh engine Rob Pike wasknown for a lot of stuff out of bellLabs including his work on the Unix teamand the plan 9 operatingsystem the two of them along with KenThompson who co-invented Unix along withDennis Richie they're all known as theco-creators of go so anyway according torob a couple of Google employees hadrecently given a talk on all the newstuff that was coming out in C++ 11 andin the span of about an hour he countedsomething like 35 new features that werebeing planned and somewhere in there heasked himself a questiondid the C++ committee really believethat what was wrong with C++ was that itdidn't have enough features surely itwould be a greater achievement tosimplify the language rather than to addtoit now Rob made this observation in themidst of a period of tremendous growthat Google the breath of Google'sproducts and services was growing usagewas growing and the engineering teams atGoogle that built and maintained allthat stuff was growing too so that meanta lot more people writing a lot morecode and coordinating all of thatcarried a whole lot of newoverhead and since Google's business isall about scale this problem was onlygoing to getworse and this is where go was bornGoogle was struggling with its scale thecomplexity of a massive code base withso many developers working on the sameprojects in Java and C++ had led tobrittle code and diminished productivityand Go's Vision was hey let's prioritizethis scale and that means accounting forhow modern software is architected theenvironments in which modern workloadsrun and most importantly the teams whowrite operate and maintain itall so on that basis from when Rob andRobert started in 2007 to when go1 wasreleased in 2012 the go team worked toDefine Go's founding principles andbuild it for release so this includesmaking an source project which we did in2009 and then ensuring that what we callgo 1.0 is usable in part by putting itinproduction now one of the key bits inGoogle a go one's release notes was thisemphatically stated point the drivingmotivation for go1 is stability for itsusers people should be able to write goprograms and expect that they willcontinue to compile and run withoutchange you know some programminglanguages are good good at this some arenot we're going to be really good atit and in fact we released go1 with aseparate document that explains ourcompatibility guidelines in more detailwe call it the go compatibility promiseand there we wrote it is intended thatprograms written to the go1specification will continue to compileand run correctly unchanged over thelifetime of that specification and thishas been a Hallmark of our releases eversince you know in effect go 1.0 was asort of long-term release that wecontinue to support any point releasethat follows go 1.1 1.2 1.21 which wejust released earlier this month theyall continue to be compatible with go1.0 and the reason the compatibilitypromise is so important is because whatwe sought to release in go1 was not justa programming language but rather aplatform for software engineering so thevision wasn't to compete with C++ on thenumber of new features we could add thevision was to facilitate real worldsoftware engineering at scale and that'sthe sort of software that's written inteams where members come and go wherethere are deadlines slas all thatstuff and that sort of engineeringreally requires long-term predictabilityyou know not breaking existing code orcreating a Perpetual maintenance burdenit also requires accounting for the factthat development is more than just theprogramming language you use it's thissort of multi-stage life cycle withdifferent intersecting tools that's theidea of aplatform so in addition to thecompatibility promise go one shippedwith all of this stuff on the slide tooall of it out of the box so instead ofimporting a third-party library fortesting or finding and agreeing on astyle guide go one started on thismission of providing our developers anentire platform for everything you needto ship good scalable software ware inteams so that was version one nextbetween 2012 and 2015 as developers werebeginning to to to adopt go we focusedour efforts on refining everything likeany software project the first fewversions of go had all these rough edgesand actual usage helped us see that andfor go this was a multi-year processculminating in 2015 with go1.5 the compiler and runtime they wereRewritten from C to go and that's sortof like this important WR of passage ofa programming language of this sortwhere the compiler is written in thelanguage that it compiles the garbage Lgarbage collector was revamped thestandard library was hardened runtimeperformance was improved just variousthings were improved or fixedthroughout but despite all this changethe compatibility promise from go oneapplied as we wrote in the release notesversion 1.5 is a significant releaseincluding major architectural changes tothe implementation despite that weexpect almost all go programs tocontinue to compile and run as beforebecause the release still maintains thego1 promise ofcompatibility now you may have noticedon a slide earlier that Goan alreadyshipped with dependency management butin 2018 the concept of modules wasintroduced which took Go's dependencymanagement to the next level and starteda new parallel consideration in ourdevelopment Focusyou see around this time there had beenanother important development go wasbecoming increasingly important inindustry for one the entire Cloud wasbeing built on go so this includes gcpbut it also includes AWS and Azure andall the different important tools andservices that were becoming a core partof cloud-based softwaredevelopment Enterprises began to adoptgo as well using it for really importantbusiness critical systems andinfrastructure and we realized that asgo was growing especially in these hugeinfrastructure projects the importanceof security was growing as well somodules were introduced and on aconceptual level modules reallyrepresented a fundamental shift in onehow go code was written and packaged andtwo how go code especially third partylibraries was distributed and then theecosystem that followedthat so on this second point the changedistribution before modules you would goget to download your dependenciesdirectly from their origin on GitHub orwherever else and the introduction ofmodules alone didn't change that but animportant property of modules is thattheir contents for each version areimmutable and this providesopportunities for caching andauthentication and we took advantage ofthis immutability property to introducethe go module mirror and check somedatabase so with the module mirror nowwe could cache all these libraries andbecause we know they're immutable we canserve them much more efficiently whichmakes dependency downloads faster andthen by caching them we can protect youfrom your dependencies disappearing fromtheir originallocations separately with the check somedatabase we're able to store a hash ofall of the source code in all of thesedependencies all of them which allows usto detect whether the source of theorigin has changed since we first saw itwhich protects you againstman-in-the-middle attacks and othertampering of yourdependencies now the module mirror andcheckum database they don't tell youwhether a dependency has a vulnerabilityto start but by recording the hash thefirst time any go user Imports thatdependency we can detect whether whethera module changes on any subsequentimport by any go user anywhere so inother words the bits you or anyone elseget that first time are the very samebits that everyone gets on everysubsequenttime so we talked about modules in themodule mirror and the checkum databasearound the same time as that we alsostarted seeing a lot of reallyhigh-profile software supply chainattacks this is the kind of thing wherean attacker would inject a vulnerabilityin a commonly used open- Source libraryand then this could affect huge swats ofa language ecosystem you can think oflog forj and Java for example and Ithink if you watch developer keynoteearlier today they they were talkingabout thatsome and that's where I really leanedinto Go's security posture andcapabilities in go18 we introducesupport for ES bombs or software buildmaterials so this means that the gocompiler writes into every binary itbuilds all the versions and dependenciesin the source which allows you to laterverify that everything is correct withjust thebinary in in go18 we also introduced abuiltin fuzzer the first majorprogramming language with Native fuzztesting built into and integrated withits standard tool chain you can think offuzzing as like a form of automatedtesting that intelligently manipulatesinputs to your programs to flesh outbugs this especially valuable whentrying to look for securityvulnerabilities and most recently welaunched our end to-end vulnerabilitymanagement system which surfaces knownvulnerabilities in your dependencieseverywhere from your IDE to runtime wejust launched this into GA last monthand I'll spend some more time showingyou more about it later in thispresentation so that brings us to todayand I should add that we did also doanother important thing in between allof this which is of course theintroduction ofgenerics these were also introduced ingo18 generics were the single mostrequested feature of all time and thesingle most significant change ever madeto the language generics don't directlyimpact security so I won't dig too deephere but I just want to make this onepoint when I showed you this slideearlier the go compatibility promise Iglossed over a piece at the end so Ibring this up because in the Yearsleading up to the release of go18 therehave been a lot of talk about doing arelatively larger overhaul that we'dcall go2 and leading into the work thateventually became go18 we realized thismight be goto you know generics inparticular they're not only the biggestchange we've ever made to the languagethey're likely the biggest change we'llever make to thelanguage but it wasn't go to it wasgo18 and the question that arose withthe caveat and the compatibility promisewas well when will gotohappen and the answer is never therewill not be a goto that breaks go1programs there will be major revisionslike what we saw in go 1.5 and go18 butthey'll never break your programsinstead we've actually doubled down oncompatibility in go 121 which I said wereleased earlier this month we includeda lot of new functionality that lets youforce compatibility with a specificversion of go so even though we promisecompatibility today you can upgrade nowwhether or not you trust that promisewhich ensures you get the latestsecurity patches at almost no risk ofbreaking yourcode we really believe that priorprioritizing compatibility was thesingle most important design decision wemade for go one and it's not just aconvenience or reliability ormaintainability thing it's a securityfeature if upgrades are hard or requirework then it's expensive or risky to dothem and that means you won't be asquick to fix securityproblems and that sort of summarizes ourmission and the purpose of go and leadsinto how we continue to pursue the coreVision that started this project in thefirst placeyou know all those things we learned inthe last 13 to 14 years the things wefocused on the impact we had sort ofreduces to the mission in the title ofthis slide go provides the mostproductive platform for buildingproductionsystems it's productive because it'seasy to learn and maintain and scaleacrossteams it's a platform because it's morethan a language it's an end-to-enddeveloperexperience and it's production readybecause it's reliable efficient stableand moresecure so let's take a look at thatsecurity part now and in particular thebit about software supply chain securityand the first thing is well what is asoftware supply chain so most softwarethat we write it's composed of both thesource code that you write and then thethirdparty libraries that you rely on asdependencies usually a build processcombines these sources and outputs foryou package software and this in turncan be run directly by your organizationor it can be consumed by other partiesas theirdependencies your dependencies can beopen source or they can be off the shelfbut either way they'll have contributorsand they'll have dependencies of theirown and all of this together constitutesa software supply chain and you can be asupplier you can be a consumer or morelikely you can beboth now increasingly the softwaresupply chain has itself become a vectorfor attacks as I said in the lastsection you can think of the attacksyou've seen in the news like log 4J oror solar winds where some part of thissoftware development life cycle iscompromised these attacks alldemonstrate that there are actuallyseveral different vulnerable surfaces inyour software supplychain for example an attacker couldcompromise your Source Code by injectingbad code into your repository or bycompromising your Source controlsystem an attacker might compromise yourbuild system Say by injecting avulnerability into the compiler or theuh the container you use to host yourbuildprocess an attacker might compromiseyour packaging for example by injectinga bad artifact into your cicdprocess and of course you can beattacked at runtime Which is less of asupply chain attack at this point butlike something like a Dos or somethingthat targets a problem in your runtimeenvironment so go contributes to all ofthese steps and combined with otherofferings of gcp you can protectyourself even more but for purposes ofthis presentation I'm going to focusmostly on attacks here in red uh theseare the ones in your dependenciesattacks here are like what you saw inlog 4J where vulnerability in one of themost popular open source dependencies inJava just caused an absolute nightmarein the entire Javaecosystem basically the vulnerabilityallowed an attacker to launch a remotecode execution attack just by injectingmalicious code in any string that gotpicked up by the log 4J logger soanything that was logged it's extremelysimple it's easy to to pull off and younever expect it because everyone trustedlog4J so I'll walk through that a bit byusing an example to sort of understandwhat an attack like this might look likesay you're writing package a and to dothat you depend on several otherpackages which provide you somefunctionality they in turn might dependon other packages and soon now let's say there's a vulnerabilitydeep in your dependency tree deep andfar away as it is this vulnerabilitycould have consequences for yourproject and that's because the problemisn't isolated to package K it couldaffect I it could affect anything thatdepends on I like BC D or E and worst ofall it could affect you because of someproblem in some Leaf package that you'venever even heard of with the web ofdependencies relying on otherdependencies getting larger and morecomplicated there's lots of places tostuff of vulnerability that affect wideswaths of a language ecosystem this iswhat we saw in log 4J and there's lotsof other examples out there in otherlanguage ecosystems and this is in partbecause dependency graphs can be reallycomplicated and that makes vulnerabilitydetection REM remediation a lotharder so you may think that yourdependency graph looks like this butreally it probably looks more like thisdependency graphs are extremely complexthe rendering on this Slide by the waydescribes kubernetes which as I'm suremost of you know is written ingo so that's the problem now how does gohelp well in go we solve for this andother security problems by addressing itall end to endend throughout the entiresoftware development life cycle andwe're able to do this because as I saidearlier go is not just a programminglanguage it's a platform so we cancreate these endtoend IntegratedSolutions so this slide highlights someof how we do that with sec security moregenerally all of it's out of thebox and if we want to hone in on supplychain security well we've created anendtoend solution for vulnerabilitymanagement which as I mentioned wereleased in a ga last month it'sintegrated across the entire platform soyou'll see a piece of it in all thehighlighted stepshere here's what it looks like on a highlevel first we have the data itself soin order to create a comprehensive datasource of all known vulnerabilities inthe go ecosystem we pull vulnerabilitydata from a variety of places likeGitHub security advisories CVS from thenational vulnerability database securityreleases for the go project itself anddirect reports from go packagemaintainers the goal here is to create asingle source of Truth for the whole goecosystem vulnerabilities from all thesedata sources are individually reviewedcurated and then aggregated into the govulnerability database when we curatethis data we ensure that the datamaintains a consistent quality and stylebut we also identify for each report theaffected packages symbols andversions by structuring the data likethis we can make the data more readablebut more importantly more actionable foryourdevelopers this is because a hugeproportion of the code in modernapplication is actually contained inyour open source dependencies but only asmall fraction of that code is actuallyin use so this means that when yourdevelopers are investigating securityvulnerabilities odds are pretty goodthat the vulnerable code is not actuallyin use in other words thosevulnerabilities are not reachable andthe time iswasted so this is where go really leadsnot only is vulnerability managementbuilt into the tool chain go goes vulnerunability management tools theyemphasize productive vulnerabilityinvestigation because the database haspackages symbols and versions our toolsare able to detect whether thesevulnerabilities are actually invoked byyour application which saves yourdevelopers a lot oftime and speaking of tools we've madeall of this data and functionality easyto find and use most of all byintegrating it across all of ourdeveloper touch points so you can learnabout the ones that might affect yourdependencies on our package site saybefore you choose to use the dependencyat all you can use our command line toolto check at the command line or in Ci orto monitor in production and you candetect and fix uh vulnerabilities inyour IDE as well through our integrationwith our extension for vscode so let's take a quick look at theseIntegrations starting with our packagesite at PKG doggo.d so say you're on pg. go.d you'researching for a package you might wantto pull into yourproject if that package has avulnerability there'll be a red bannerat the top of the page giving you aquick preview of what that vulnerabilityis if you click into it you can checkthe details to learn more like when itwas first introduced or what symbols areactuallyvulnerable if you're using a differentversion of the module you can click onthe versions page to see what otherversions may be affected this view alsoshows you which versions of the modulemay suffer from other vulnerabilities aswell next we've created a command linetool which makes using all of this datain the in the database easy so you canscan directly from your command line andin your CI pipeline we call this tool govul check and it leverages thevulnerability database to filter outfalse positives and return to you thestuff that you should actuallyinvestigate this reduces a ton of noisethat makes that process so burdensomemost of the time and it works onbinaries as well so meaning you can usethis to monitor your application afterit's already in production say alertingyou to vulnerabilities that werediscovered after you already shippedit so this is an example of what goonlooks like so up top we've invoked goonon our project goon analyzes ourcodebase and Compares all of ourdependencies against the govulnerabilitydatabase the first part of our outputreports back vulnerabilities that weknow affect our code base this isdetermined based on which functions inour code are actually transitivelycalling the vulnerable symbols usingthat symbol data from thedatabase the bottom half tells us aboutvulnerabilities and packages that weimport but which are not called so thisis informational we aren't exposed tothe vulnerabilities in these packagesbut maybe we'd like to know about themanyway and of course we can always goback to PKG go.d to look up thesepackages uh learn more about thevulnerabilities and get otherinformation so finally we've integratedgo vul Che into the go extension forvisual studio code which then allows youto check your dependencies whether theyhave vulnerabilities as soon as youimport them so if it reports avulnerability but you choose to keep thedependency anyway say because you don'tthink it affects you the go plug-in willwarn you again if your code does end upinvoking that vulner ility lateron this means that you can scan and fixyour vulnerabilities directly in youreditor at the very earliest stage of thedevelopment life cycle a lot of userstell me that this is their favorite partbecause it enables developers whootherwise never think about security toactually begin contributing to thesecurity process they sort of become thefirst line ofdefense here's an example of what itlooks like so you can get output from goVon in your vs code terminal like we wehave on this slide it's the same outputyou would have gotten at the commandline from gooneChe or we can hover over ourdependencies in our go.mod file andthose with vulnerabilities will show youthe same information in in anoverlay and from our go do mod we thenhave the option to fix the vulnerabilityeither by upgrading to the the verylatest version of this dependency or tothe first version of this dependencywhere the vulnerability was fixed sothis makes vulnerability managementreally easy to incorporate into yourexisting workflows you never have toleave yourIDE and that's goes vulnerabilitymanagement you get all of these benefitswith or without Google cloud and wethink go really sets the bar here forwhat you should expect from yourlanguageecosystem before we wrap up recall thisslide from earlier the solutions we duginto they're really about securing yourdependencies the part on the bottom sogo provides a lot of other sec securityfeatures too stuff like native fuzzingmemory safety static binaries and all ofthese features they help at all theseother stages of the software developmentlife cycle this all provides a reallygreat Foundation especially for yourbusiness critical systems andinfrastructure but if you really want tobuild on top of that Foundation sort ofhard in at these other stages especiallyif you're using other programminglanguages in your deployment Google CLcloud has a lot of really cool productsthat I encourage you all to check out aswell you know Google Cloud Prides itselfon providing the best possible supportfor go workloads it's all Google afterall and these other products work reallywell to supplement your protection ontop of that for even more Security inmoreplaces and that's it before I takequestions uh please remember to give meany feedback in the cloud next app goodor bad but especiallygood and I hope you all found thissession useful and thank you for takingthetimehey"
}